---
title: "urban_gauge"
author: "John Gardner"
date: "May 8, 2020"
output: html_document
---

```{r setup, include=FALSE}
# LOAD packages
library(stringr)
library(tidyverse)
library(feather)
library(sf)
library(rgdal)
library(maps)
library(magrittr)
library(purrr)
library(data.table)
library(tmap)
library(readr)
library(lubridate)
#library(raster)
library(mapview)
library(ggthemes)
library(vroom) 
library(leaflet)
library(tidyr)
library(leafpop)
library(USAboundaries)
library(tigris)
library(tidycensus)
library(knitr)
library(dataRetrieval)

knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

```{r census_API, include=F, eval=T, echo=F}

### get census API key at  http://api.census.gov/data/key_signup.html

### Run this only first time
#census_api_key("739f668cac5542524a7b3a5e3977032eb3319330", overwrite = T, install =T)

###  First time, reload your environment so you can use the key without restarting R.
#readRenviron("~/.Renviron")

###  You can check it with:And use this to re-load key in future sessions
Sys.getenv("CENSUS_API_KEY")


```


```{r census_data, echo=F, include=F}
#### get census data

### find which variable is total population
#v17 <- load_variables(2017, "acs1", cache = TRUE)
#pop_v17 <- v17 %>% 
#  filter(grepl("POP", concept)) %>% 
#  as.data.frame()

### download total population estimates for urban boundaries >65000 by year
years <- lst( 2005, 2006, 2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018)

pop_urban <- purrr::map_dfr(
  years,
  ~ get_acs(
    geography = "urban area",
    variable = "B01003_001",
    year = .x,
    survey = "acs1",
    geometry = F
    ),
  .id="year"
)

#download urban area simple geometry
urban <- urban_areas(cb=T, class="sf")

```


# 55% of cities with population >65,000 do NOT have any USGS gauges in the boundaries

# OF the 4557 GAGES2 gauges, 84% are outside city boundaries, 16% inside city boundaries

```{r spatial_intersect, echo=F}

## load usgs gauges
gauge <- read_csv("in/SitestoJG.csv") %>%
  mutate(site_no = str_pad(STAID , 8, pad="0")) %>%
  st_as_sf(coords= c("LNG_GAGE", "LAT_GAGE"), crs=4269)
 
### FIND gauges IN urban boundaries. 
# filter urban areas to ones with pop data first.
gauge_urban_join <- gauge %>%
  st_transform(2163) %>%
  st_join(urban %>%
            filter(GEOID10 %in% unique(pop_urban$GEOID)) %>%
            st_transform(2163),
          join=st_intersects)

### interactive map of all gauges colored by city they are in
mapview(gauge_urban_join, zcol="GEOID10", legend=F, layer.name= "Gauges") +
  mapview(urban %>%
            filter(GEOID10 %in% unique(pop_urban$GEOID)), zcol="GEOID10", legend=F, layer.name="Urban Boundaries")

# estimate percent of all gauges in urban areas
knitr::kable(gauge_urban_join %>%
  st_set_geometry(NULL) %>%
  mutate(urban_gauge = ifelse(is.na(GEOID10), "No","Yes")) %>%
  group_by(urban_gauge) %>%
  summarise(Count = n()) %>%
  mutate(Percent = Count/sum(Count)*100),
  digits=2, align="c", caption= "# gauges IN cities >65,000 people" )

# estimate how many cities have gauges or not
cities_wo_gauge <- urban %>%
  filter(GEOID10 %in% unique(pop_urban$GEOID)) %>%
  st_set_geometry(NULL) %>%
  left_join(gauge_urban_join %>%
              st_set_geometry(NULL) %>%
              select(GEOID10) %>%
              distinct(GEOID10) %>%
              mutate(has_gauge ="YES"),
            by="GEOID10") %>%
  mutate(has_gauge = ifelse(is.na(has_gauge), "NO", has_gauge))

knitr::kable(cities_wo_gauge %>%
  group_by(has_gauge) %>%
  summarise(Count=n()) %>%
  mutate(Percent = Count/sum(Count)*100),
  digits=2, align="c", caption="# cities with gauges")


```



# Top 100 large cities (mean 2005-2018) and their median rate of year to year population change and the location of gages IN city boundaries

```{r summary, echo=F}
 
# make figs map pop increasing or decreasing

pop_urban_sum <- pop_urban %>%
  mutate(year = as.numeric(year)) %>%
  group_by(GEOID) %>%
  arrange(year) %>%
  mutate(mean_pop= mean(estimate, na.rm=T),
         lag_pop = lag(estimate),
         pct_change = ((estimate-lag_pop)/lag_pop) *100) %>%
  mutate(mean_pct_change = mean(pct_change, na.rm=T),
         median_pct_change = median(pct_change, na.rm = T))  %>%
  ungroup() %>%
  arrange(GEOID, year)


pop_plot <- pop_urban_sum %>%
  group_by(GEOID) %>%
  filter(year == max(year, na.rm = T)) %>%
  ungroup() %>%
  arrange(desc(mean_pop)) %>%
  slice(1:100) %>%
  mutate(
    population = case_when(
      median_pct_change < 0 ~ "Decreasing",
      median_pct_change > 0 ~ "Increasing",
      median_pct_change == 0 ~ "No Change"))

mapview(urban %>%
          inner_join(pop_plot, by=c("GEOID10"="GEOID")),
                     zcol="population", layer.name="Median % pop change", alpha=0.5)  +
  mapview(gauge_urban_join %>%
            filter(GEOID10 %in% pop_plot$GEOID), col="black", col.regions="black", alpha=0.5, cex=0.7, layer.name="Urban Gauges")


# pin population time series to boundaries for interactive map


# pin flow time series to gauges for interactive map

```



```{r buffer, include=F, echo=F}

### FIND gauges IN 1 km BUFFER boundaries. 

# # filter urban areas to ones with pop data first.
# gauge_urban_join <- gauge %>%
#   st_transform(2163) %>%
#   st_join(urban %>%
#             filter(GEOID10 %in% unique(pop_urban$GEOID)) %>%
#             st_transform(2163),
#           join=st_intersects)
# 
# ### interactive map of all gauges colored by city they are in
# mapview(gauge_urban_join, zcol="GEOID10", legend=F) +
#   mapview(urban %>%
#             filter(GEOID10 %in% unique(pop_urban$GEOID)), zcol="GEOID10", legend=F)
# 
# # estimate percent of all gauges in urban areas
# knitr::kable(gauge_urban_join %>%
#   st_set_geometry(NULL) %>%
#   mutate(urban_gauge = ifelse(is.na(GEOID10), "No","Yes")) %>%
#   group_by(urban_gauge) %>%
#   summarise(Count = n()) %>%
#   mutate(Percent = Count/sum(Count)*100),
#   digits=2, align="c", caption= "# gauges IN cities >65,000 people" )
# 
# 
# cities_wo_gauge <- urban %>%
#   filter(GEOID10 %in% unique(pop_urban$GEOID)) %>%
#   st_set_geometry(NULL) %>%
#   left_join(gauge_urban_join %>%
#               st_set_geometry(NULL) %>%
#               select(GEOID10) %>%
#               distinct(GEOID10) %>%
#               mutate(has_gauge ="YES"),
#             by="GEOID10") %>%
#   mutate(has_gauge = ifelse(is.na(has_gauge), "NO", has_gauge))
# 
# 
# knitr::kable(cities_wo_gauge %>%
#   group_by(has_gauge) %>%
#   summarise(Count=n()) %>%
#   mutate(Percent = Count/sum(Count)*100),
#   digits=2, align="c", caption="# cities with gauges")
# 
# 
# write_csv(pop_urban, "out/urban_areas_pop_2005_2018.csv")
# 
# st_write(urban, "out/urban_areas_boundaries.shp")
# 
# write_csv(gauge_urban_join %>%
#             filter(!is.na(GEOID10)), "out/gauges_IN_cities.csv")



```




```{r save, include=F, echo=F}


#write_csv(pop_urban, "out/urban_areas_pop_2005_2018.csv")

#st_write(urban, "out/urban_areas_boundaries.shp")

#write_csv(gauge_urban_join %>%
#            filter(!is.na(GEOID10)), "out/gauges_IN_cities.csv")


```



Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
